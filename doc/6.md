# Двоичные деревья поиска. Анализ алгоритма сортировки с помощью двоичного дерева.

**Двоичные деревья** - это структуры данных, состоящие из узлов, которые хранят значение, а также ссылку на свою левую и правую ветвь. 

Каждая ветвь, в свою очередь, является деревом. Узел, который находится н самой вершине дерева принято называть корнем, узлы, находящиеся в самом низу дерева и не имеющие потомков называют листьями. Ветви узла называют потомками. По отношению к своим потомкам узел является родителем или предком. Также, развивая аналогию, имеются сестринские узлы - узлы с общим родителем

Бинарное дерево, это единственная в своем роде структура представления данных. Используется, например, для реализации базы данных.

## Анализ алгоритма сортировки с помощью двоичного дерева

Сортировка с помощью дерева осуществляется на основе бинарного дерева поиска Бинарное (двоичное) дерево поиска - это бинарное дерево, для которого выполняются следующие дополнительные условия (свойства дерева поиска):

* оба поддерева - левое и правое, являются двоичными деревьями поиска
* у всех узлов левого поддерева произвольного узла X значения ключей данных меньше, чем значение ключа данных самого узла X;
* у всех узлов правого поддерева произвольного узла X значения ключей данных не меньше, чем значение ключа данных узла X.

Данные в каждом узле должны обладать ключами, на которых определена операция сравнения меньше.

Для сортировки с помощью дерева исходная сортируемая последовательность представляется в виде структуры данных "дерево".

Например, исходная последовательность имеет вид: 4, 3, 5, 1, 7, 8, 6, 2

Корнем дерева будет начальный элемент последовательности Далее все элементы, меньшие корневого, располагаются в левом поддереве, все элементы, большие корневого, располагаются в правом поддереве Причем это правило должно соблюдаться на каждом уровне

После того, как все элементы размещены в структуре "дерево", необходимо вывести их, используя обход дерева в симметричном порядке (слева направо)

Используется, например, для сортировки по именам в базе данных в виде бинарного дерева.

Анализ:
Если элементы массива различны и расположены в случайном порядке, а длина массива N, алгоритм требует в среднем O(n log n) операций. Если они уже отсортированы в возрастающем или убывающем порядке, то дерево становится несбалансированным (то есть у него появляется много пустых веток). Тогда алгоритм требует О(n^2) операций, и это худший возможный случай.