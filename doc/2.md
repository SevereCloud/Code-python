# Сортировка вставками. Сортировка слиянием. Анализ алгоритмов сортировки.

**Дано:** последовательность чисел **a1, a2 ... an**  
**Вывод:** перестановка **a1, a2 ... an**, где **a1 < a2 < ... < an**

## Сортировка вставками

Считаем, что первый элемент отсортирован, поэтому ставим указатель на 2 элемент.

Если элемент слева больше, то меняем их местами. Снова сравниваем, до тех пор пока элемент слева будет равен или меньше чем наш, или пока мы не дойдем до начала массива.

Перемещаем указатель вправо и опять сравниваем.

![тут должна быть картинка](https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif)  
*Красный указатель*
```python
for i in range(1, len(A)):
    key = A[i]
    m = i
    while (A[m-1] > key) & (m > 0):
        A[m] = A[m-1]
        m -= 1
    A[m] = key
```

Мы имеем два цикла, каждый из которых повторяется примерно по **cn** раз, значит худшее время **n²**  
Так как мы используем только массив **A[1..n]**, значит затрата памяти n

Вычислительная сложность: **O(n²)**   
Затрата памяти: **O(n)**

## Сортировка слиянием

1. Массив разбивается на две равные части
2. Каждая из получившихся частей рекурсивно сортируется  
Рекурсивное разбиение задачи на меньшие происходит до тех пор, пока размер массива не достигнет единицы.
3. Два упорядоченных массива соединяются в один

Пусть мы имеем два уже отсортированных по неубыванию подмассива. Тогда:  
3.2. Слияние двух подмассивов в третий результирующий массив.  
На каждом шаге мы берём меньший из двух первых элементов подмассивов и записываем его в результирующий массив. Счётчики номеров элементов результирующего массива и подмассива, из которого был взят элемент, увеличиваем на 1.  
3.3. «Прицепление» остатка.  
Когда один из подмассивов закончился, мы добавляем все оставшиеся элементы второго подмассива в результирующий массив.  


![тут должна быть картинка](https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif)


```python
def mergesort(A):
    if len(A) > 1:
        mid = int(len(A)/2)
        lefthalf = A[:mid]
        righthalf = A[mid:]

        mergesort(lefthalf)
        mergesort(righthalf)

        i = 0
        j = 0
        k = 0
        while i < len(lefthalf) and j < len(righthalf):
            if lefthalf[i] < righthalf[j]:
                A[k] = lefthalf[i]
                i = i + 1
            else:
                A[k] = righthalf[j]
                j = j + 1
            k = k + 1

        while i < len(lefthalf):
            A[k] = lefthalf[i]
            i = i+1
            k = k+1

        while j < len(righthalf):
            A[k] = righthalf[j]
            j = j + 1
            k = k + 1
    return A      
```

Построим дерево рекурсии  
![тут должна быть картинка](2.1.png)

Один уровень равен **cn**  
Количество уровней дерева(высота) **lg n + 1**

>Общее количество уровней дерева рекурсии на рисунке равно lg n + 1, где n — количество листьев, соответствующее размеру входных данных. Это легко понять из неформальных индуктивных рассуждений. В простейшем случае, когда n = 1, имеется всего один уровень. Поскольку lg 1 =0, выражение lg n + 1 дает правильное количество уровней.  

**(lg n + 1) * cn = cn log n + cn**, значит худшее время **n log n**  
Так как мы используем только массив **A[1..n]**, значит затрата памяти n

Вычислительная сложность: **O(n log n)**   
Затрата памяти: **O(n)**
